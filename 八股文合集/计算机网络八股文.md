

# 网络模型有哪几层？

**应用层**

我们电脑或手机使用的应用软件是在**应用层**运行的。

当两个不同设备的应用需要进行通信时，应用会将应用数据传递给下一层，即**传输层**。

**传输层**

主要的协议有TCP和UDP。**TCP是一种可靠的**、**面向连接的协议**，它负责确保数据按照顺序**安全**传输；而UDP则是一种**不可靠的、无连接的协议**，主要用于一些对**实时性要求较高**的应用，如流媒体和实时游戏。

**网络层**

世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号比如ip,所以网络层主要负责实现不同网络之间的数据传输

**数据链路层**

**物理层**

# Http1.0 /1.1/2.0的区别 

**1.0**

浏览器跟服务器建立短暂连接,每次请求都会建立一个tcp连接

**1.1**

- 更改为长连接,每次请求都会复用前几次的tcp连接
- 一个连接可以发起多次请求
- 但是会出现阻塞情况,比如说我后面的情况需要顺序等待前面的请求执行完(排队点餐)
- 新增请求方法put,delete

**2.0**

- 使用io多路复`用来解决阻塞问题,他可以做到一个请求并发执行
- 然后文本格式改为二进制格式
- 然后采用报头压缩,降低开销
- 服务器可以推送

# **从浏览器地址栏输入 url 到显示主页的过程？**   *

1. ==DNS解析==:域名解析为ip,当你输入域名的时候,首先会开始DNS解析,解析就是将域名解析为ip地址
1. TCP连接:通过ip和tcp建立连接然后通过这个ip地址去和TCP建立连接,一般时https这个过程涉及三次握手,然后握手成功还需要和ssl安全协议握手,然后通过443端口和hhtps建立连接
1. HTTP:发送请求行、请求体、请求头,建立连接后会通过http发送请求,请求包含请求头,请求体,请求行发给服务端
1. 服务端接收:返回响应头、响应体、状态行服务端接收http请求之后,经过后端处理,返回响应头,响应体,状态行
1. 浏览器接收HTTP响应:渲染,html,javastrcip,css浏览器接收http响应之后会对响应体里的html内容进行解析,并且会渲染css,javastcip
1. 断开连接:四次挥手断开连接

# URI 和 URL 有什么区别? 

- URI，统一资源标识符，标识的是 Web 上每一种可用的资源，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。

- URL，统一资源定位符，它是 URI 的一种子集，主要作用是提供资源的路径。

总结:它们的主要区别在于，URL 除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx 职业技术学院/14 号宿舍楼/525 号寝/张三.男。

# HTTP常见状态码

| **2xx** | **成功标识** |                                                          |
| ------- | ------------ | -------------------------------------------------------- |
|         | 200          | 成功标识,携带响应头有body数据                            |
|         | 204          | 成功标识,携带响应头没有有body数据                        |
|         | 206          | 成功标识,一般是断点续传和分块下载,返回地body不是全部数据 |
| **3xx** | 重定向       |                                                          |
|         | 301          | 永久重定向,请求资源不在了,需要用新的url再次访问          |
|         | 302          | 临时重定向,请求资源还在,只是暂时需要新的url访问          |
| **4xx** |              |                                                          |
|         | 401          | 没登陆通常报401                                          |
|         | 403          | 没权限,进制访问服务器资源                                |
|         | 404          | 一般是找不到资源,看看是不是url写错了                     |
| **5xx** |              |                                                          |
|         | 500          | 只知道服务器内部发生问题了                               |
|         |              |                                                          |

# Http和https区别是什么

**安全**

http三次握手之后就建立连接,而http**s**三次握手之后还需要对ssl/Tls安全协议握手才能建立连接

**端口**

http端口是`80`和http**s**是`443`

**数字证书**

https需要申请一个数字证书来保证服务是可信的

# websocket是什么和http区别呢?

是这样的,像平时扫码登录这种有些使用http实现如果是使用http不断轮询的话,会出现扫码之后等个一俩秒才登录,这个体验非常不好,解决方案就是长轮询,这样可以解决,不过像平时的网页啊你点进去突然右下角搞个弹窗,然后哎你不小心点进去了,弹出我是渣渣灰,那来都来了就玩玩呗,然后你就发现你鼠标动都没动,他就疯狂给你升级,小怪走过来给你包金币,这实在太暖心了(笑着说),那么这种服务器主动发消息给客户端是怎么实现的呢,就是通过websocket来实现,他是全双工的,双方都可以主动向对方发送数据

webscoket适合实时性比较强的场景,比如chatgpt聊天,

# http和rpc区别

- rpc其实是80年代比较常用而http是90年代,所以其实这个问题反而是为什么有rpc还需要http
- 这是因为80年代那会大家都是自己客户端跟服务端建立连接,就比如安全卫士,360管家 C/S
- 而现在由于有浏览器这种东西,他需要访问自己的服务端和别人的服务端,所以说基于这种B/S架构就有了http

**最主要的区别**

http每次传过来的请求头和请求体比较冗余而rpc是可以以体积更小的保存数据,而且rpc**不需要考虑浏览器的各种行为比如重定向**,所以性能更好是我认为的主要原因

# **get和post区别**

get是从服务器上获取数据,get传送的**数据量较小**，get**安全性非常低**,执行**效率好**。

post是向服务器传送数据post传送的**数据量较大**，post**安全性较高**,执行**效率不够好**。在进行文件上传时只能使用post而不能是get。

# 三次握手  *

## 三次握手流程

TCP（传输控制协议）的三次握手机制是一种用于在两个 TCP 主机之间建立一个可靠的连接的过程。这个机制确保了两端的通信是同步的，并且在数据传输开始前，双方都准备好了进行通信。

![三分恶面渣逆袭：TCP 三次握手示意图](https://pic-1329573580.cos.ap-nanjing.myqcloud.com/202410131714567.jpeg)

那我再说一下三次握手 🤝 的过程：

①、第一次握手：SYN（最开始都是 CLOSE，之后服务器进入 LISTEN）

- **发起连接**：客户端发送一个 TCP 报文段到服务器。这个报文段的头部中，SYN 位被设置为 1，表明这是一个连接请求。同时，客户端会随机选择一个序列号（Sequence Number），假设为 x，发送给服务器。
- **目的**：客户端通知服务器它希望建立连接，并告知服务器自己的初始序列号。
- **状态**：客户端进入 SYN_SENT 状态。

②、第二次握手：SYN + ACK

- **确认并应答**：服务器收到客户端的连接请求后，如果同意建立连接，它会发送一个应答 TCP 报文段给客户端。在这个报文段中，SYN 位和 ACK 位都被设置为 1。服务器也会选择自己的一个随机序列号，假设为 y，并将客户端的序列号加 1（即 x+1）作为确认号（Acknowledgment Number），发送给客户端。
- **目的**：服务器告诉客户端，它的连接请求被接受了，并通知客户端自己的初始序列号。
- **状态**：服务器进入 SYN_RCVD 状态。

③、第三次握手：ACK

- **最终确认**：客户端收到服务器的应答后，还需要向服务器发送一个确认。这个 TCP 报文段的 ACK 位被设置为 1，确认号被设置为服务器序列号加 1（即 y+1），而自己的序列号是 x+1。
- **目的**：客户端确认收到了服务器的同步应答，完成三次握手，建立连接。
- **状态**：客户端进入 ESTABLISHED 状态，当服务器接收到这个包时，也进入 ESTABLISHED 状态

## TCP 握手为什么是三次，为什么不能是两次？不能是四次？

使用三次握手可以建立一个可靠的连接。这一过程的目的是确保双方都知道对方已准备好进行通信，并同步双方的序列号，从而保持数据包的顺序和完整性。

### 为什么 TCP 握手不能是两次？

- 为了防止服务器一直等，等到黄花菜都凉了。
- 为了防止客户端已经失效的连接请求突然又传送到了服务器。

要知道，网络传输是有延时的（要通过网络光纤、WIFI、卫星信号传输等）。

假如说客户端发起了 SYN=1 的第一次握手。服务器也及时回复了 SYN=2 和 ACK=1 的第二次握手，但是这个 ACK=1 的确认报文段因为某些原因在传输过程中丢失了。

如果没有第三次握手告诉服务器，客户端收到了服务器的回应，那服务器是不知道客户端有没有接收到的。

于是服务器就一直干巴巴地开着端口在等着客户端发消息呢，但其实客户端并没有收到服务器的回应，心灰意冷地跑了。

![三分恶面渣逆袭：无三次握手导致端口占用](https://pic-1329573580.cos.ap-nanjing.myqcloud.com/202410131714002.jpeg)三分恶面渣逆袭：无三次握手导致端口占用

这就好像你找美女要联系方式了，人家回你了，你却没听见，还以为人家看不上你，赌气地跑了；剩下的美女却一直在等你。。。

还有一种情况是，一个旧的、延迟的连接请求（SYN=1）被服务器接受，导致服务器错误地开启一个不再需要的连接。

![三分恶面渣逆袭：响应失效请求](https://pic-1329573580.cos.ap-nanjing.myqcloud.com/202410131714114.jpeg)三分恶面渣逆袭：响应失效请求

举个例子：假设你（客户端）给你的朋友（服务器）发送了一个邮件（连接请求）。因为某些原因，这封邮件迟迟没有到达朋友那里，可能是因为邮局的延误。于是你决定再发一封新的邮件。朋友收到了第二封邮件，你们成功地建立了连接并开始通信。

但是，过了很久，那封延误的旧邮件突然也到了你朋友那里。如果没有一种机制来识别和处理这种延误的邮件，你的朋友可能会以为这是一个新的连接请求，并尝试响应它，但其实你已经重新发了请求，原来的不需要了。这就导致了不必要的混乱和资源浪费。

所以我们需要“三次握手”来确认这个过程：

- 第一次握手：客户端发送 SYN 包（连接请求）给服务器，如果这个包延迟了，客户端不会一直等待，它可能会重试并发送一个新的连接请求。
- 第二次握手：服务器收到 SYN 包后，发送一个 SYN-ACK 包（确认接收到连接请求）回客户端。
- 第三次握手：客户端收到 SYN-ACK 包后，再发送一个 ACK 包给服务器，确认收到了服务器的响应。

### 为什么不是四次？

三次握手已经足够创建可靠的连接了，没有必要再多一次握手。

## 三次握手中每一次没收到报文会发生什么情况？

- 第一次握手服务端未收到 SYN 报文

服务端不会进行任何的动作，而客户端由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会重新发送 SYN 报文，如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。

- 第二次握手客户端未收到服务端响应的 ACK 报文

客户端会继续重传，直到次数限制；而服务端此时会阻塞在 accept()处，等待客户端发送 ACK 报文

- 第三次握手服务端为收到客户端发送过来的 ACK 报文

服务端同样会采用类似客户端的超时重传机制，如果重试次数超过限制，则 accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的 accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态。

## 第二次握手传回了 ACK，为什么还要传回 SYN？

ACK 是为了告诉客户端传来的数据已经接收无误。

而传回 SYN 是为了告诉客户端，服务端响应的确实是客户端发送的报文。

# cookie、session和token的区别

首先session底层是cookie

存放区别上:

- cookie数据存放在**客户端**的浏览器上，session数据放在**服务端**

安全上来说:session更好

- cookie不是很安全,如果你的电脑被黑客黑掉了,黑客可以通过查看你请求的cookie知道你的账号密码,而session解决了这种问题因为session会生成一个seesionid放入cookie里而且这个生成你没法根据这个信息判断用户数据如果主要考虑到安全应当使用session,所以重要信息可以存入session安全

性能上来说:cookie更好

- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能如果主要考虑到减轻服务器性能方面，应当使用COOKIE

共享问题:

session在多服务的情况下没法session共享,解决问题的话可以通过token,token是客户端下发的一串令牌,所以能保证每个服务都能接收到,并且他区别于cookie他能保证安全性,因为token由三部分组成,头.体.签名,三部分都是通过加密算法加密得到的一串字符,三个部分只要有一个部分不一样就会失效