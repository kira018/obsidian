# RabbitMQ

## RabbitMQ俩种模式

- 推模式：消息中间件主动将消息推送给消费者
  - 当消息到达RabbitMQ时，RabbitMQ会自动地、不断地投递消息给匹配的消费者，而不需要消费端手动来拉取
  - 优点是消费者总是有一堆在内存中待处理的消息，所以当真正去消费**消息时效率很高**。
  - 缺点就是**缓冲区可能会溢出。**
  - 由于推模式是信息到达RabbitMQ后，就会立即被投递给匹配的消费者，所以实时性非常好，消费者能及时得到最新的消息。

- 拉模式：消费者主动从消息中间件拉取消息
  - 拉模式在消费者需要时才去消息中间件拉取消息，**这段网络开销会明显增加消息延迟**，降低系统吞吐量。 
  - 由于拉模式需要消费者手动去RabbitMQ中拉取消息，所以**实时性较差**,消费者难以获取实时消息，具体什么时候能拿到新消息完全取决于消费者什么时候去拉取消息。


## RabbitMQ用来做什么,或者说使用场景?

1. 首先讲一下MQ做什么,他主要的功能就是异步解耦,比如有些逻辑是不需要在主程序中执行的,就可以通过异步来解耦,举个例子
   - 异步发送(邮件,短信)
   - 对数据库写操作有些业务也可以解耦
   - 对日志的处理

2. 那其实有些功能不用mq也可以实现,比如说发送邮件,异步解耦的一些操作,都可以通过多线程开启一个异步线程来实现,所以基于项目来考虑的话如果数据量不是特别大的情况下,简单实现就OK了,如果数据量很大的情况下就建议用专业的异步工具嘛比如MQ ,不然没必要多维护一个MQ时间成本各种成本

## RabbitMQ/RocketMQ/kafka的区别

**消息吞吐量:**

kafuka:千万级

RocketMQ:千万级

rabbit:十万级

**队列支持:**

rabiitmq:支持死信,延迟,优先队列等

kafuka:不支持

**其他:**

存储在内存中延时低,相对的内存空间少能保存的消息少,不过可以开启xx队列保存在磁盘中

**总结**

如果想使用灵活的消息路由rabbit好一点,或者数据量没那么大的情况下简单rabbit就够了

## RabbitMQ-如何保证消息不丢失(消息一致性)

首先,消息丢失有三种情况:

1. 消息可能会在交换机或者队列任何一个地方发送失败
   - 开启生产者确认机制，开启之后如果成功会生成一个ack回执,生产者收到之后就可以确认消息送达，如果交换机或者队列哪个环节报错会生成对应的报错回执,然后可以将报错回执先记录到日志中，再去修复数据

1. 第二个是消息正常发送到MQ队列中,但是MQ宕机了或者重启了这个时候消息就丢失了(mq是保存在内存中的)
   - **开启持久化功能**，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要做持久化

1. 消费者也会导致消息丢失*
   - 第三个是开启消费者确认机制为auto，由spring确认消息处理成功后完成ack，当然也需要设置一定的重试次数，我们当时设置了3次，如果重试3次还没有收到消息，就将失败后的消息投递到**异常交换机**，交由人工处理


## RabbitMQ消息的重复消费问题如何解决的(幂等问题)

**出现场景**:

1. 网络抖动
2. 消费者挂了

当消费者设置了自动确认机制，消费者返回ack给服务的时候,服务宕机了或者重启了,那消费者自动确认机制有个重试次数嘛,当他重试的时候又进行消费了,就导致多次消费

**解决:**

1. 业务唯一标识
   - 如果你的业务有业务的唯一标识,比如说支付业务里的订单id这种,我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了

1. 幂等性问题
   - 其实这个就是典型的幂等的问题，比如，redis分布式锁、数据库的锁都是可以的


总结:1.锁 2.判断 3.唯一索引兜底

## RabbitMQ中死信交换机 ? （RabbitMQ延迟队列有了解过嘛）

**场景:**

1. 超时订单
2. 限时优惠
3. 定时发布ps:微信,qq朋友圈

**怎么成为死信,以及延迟队列怎么弄**

如果消息超时未消费就会变成死信，在RabbitMQ中如果消息成为死信，队列可以绑定一个死信交换机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定TTL的时间，这样就实现了延迟队列的功能了

**延迟队列是什么**

延迟队列就是用到了死信交换机+TTL（消息存活时间）实现的。

## 如果有100万消息堆积在MQ , 如何解决 ? *

1. 提高消费者的消费能力 ,可以开启多线程进行消费

2. 增加更多消费者，提高消费速度 
   - 使用**工作队列**模式, 设置多个消费者消费消费同一个队列中的消息

3. 可以使用RabbitMQ惰性队列，惰性队列的好处主要是
   - 接收到消息后直接存入磁盘而非内存
   - 消费者要消费消息时才会从磁盘中读取并加载到内存
   - 支持数百万条的消息存储

## RabbitMQ的高可用机制有了解过嘛

我们当时项目在生产环境下，使用的集群，当时搭建是镜像模式集群，使用了3台机器。

镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失

## 出现丢数据怎么解决呢？

我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。

并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可