

# 大量if else怎么优化

工厂模式+策略模式

1.定义一个接口,然后写一个方法

2.有几个if定义几个接口实现类,并且分别实现那个方法

3.构建工厂类,然后使用map存储 value为返回地类对象

4.然后使用的时候只需要传一个值进去就能调用对应的if方法

# 前后端分离是为什么,你的理解是什么?

1. **页面展示适配性**：在不分离的情况下，针对PC端和手机端需要制作不同版本的页面，为不同平台做出页面适配，增加了开发和维护成本。
2. **性能优化**：在不分离的情况下，可能会造成不必要的资源加载和渲染，降低了性能表现。
3. **用户体验差异**：不分离的情况下，可能因为PC端和手机端差异较大导致用户体验不一致，影响应用整体质量。

# 跨域问题怎么解决

**什么是跨域?**

跨域是指,俩个页面,不同ip、端口、或者一个是ip地址一个是域名访问都是跨域

**跨域问题是什么?**

跨域问题是浏览器才有的,主要是因为**同源策略**,就像刚刚说的如果ip.....不一致的话就不让访问另一个页面的资源

**解决方案**

我项目里主要是通过nginx搭建接口网关,以[www.nginxtest.com](https://www.nginxtest.com)开头80为端口,配置俩个server AB反向代理到他们的页面访问 如果是[www.nginxtest.com/A](https://www.nginxtest.com/A)就是A这样就是同源了因为都是80端口只是/A/B不同

# Token作用是什么

**Token是什么?**

- token是计算机标识身份的一种令牌

**token作用是什么?**

- 如果用户每次访问都需要去登录会非常麻烦,这种会话技术就是用来保存他们的信息,证明访问人的身份,方便后端验证

**token登录流程**

- 客户端发起登录请求
- 后端接收到之后会进行验证,如果验证成功则返回一个token
- 这个token会保存在客户端的localstroge或者cookie
- 随后后续客户端发起请求都会携带这个token
- 而后端会对这个token验证安全性

**token构造**

header:加密算法

存储信息

signtrue:对header和存储的信息加密

# 如果对象需要去重怎么实现? 

1. 使用set
   - 如果说是对象属性的值一摸一样的话,使用set没法去重
   - 但是我们知道set底层去重是依靠hashcode还有equals来去重
   - 所以我们只需要重写hashcode方法和equlas方法就行了
   - 具体就是hashcode根据当前类的所有属性来获取一个hash,eqluas则根据属性值来比较来返回true或false

2. 给对象转stirng然后就去重应该也行,没试过


# 使用Java现有技术实现一个本地的mysql

# 怎么对接AI需要注意什么

# 多级缓存中的本地缓存oom了怎么解决

在Java中实现多级缓存时，本地缓存（通常指应用内的缓存）是重要的一环。为了防止Out Of Memory（OOM）错误，需要采取一系列策略来有效管理和优化本地缓存的内存使用。以下是一些具体的建议：

1. **合理配置JVM内存参数**：
   - 在应用上线前，根据应用的内存需求，合理配置JVM的启动参数，如-Xms（初始堆大小）、-Xmx（最大堆大小）等，以确保JVM有足够的内存空间供应用使用。

2. **选择合适的缓存实现**：
   - 使用高效的缓存实现，如Guava Cache、Caffeine等，这些缓存库提供了丰富的配置选项，如缓存大小、过期策略等，有助于精细控制缓存的内存占用。

3. **设置缓存大小和过期策略**：
   - 为本地缓存设置合理的大小上限，避免缓存无限增长。
   - 配置合适的过期策略，如基于时间的过期（TTL）或基于访问的过期（LFU、LRU等），以确保缓存中的对象能够及时释放。

4. **监控缓存使用情况**：
   - 使用JVM提供的工具（如jvisualvm、jconsole等）或自定义监控代码，定期监控本地缓存的内存使用情况，及时发现并解决潜在的内存问题。

5. **优化数据结构**：
   - 根据缓存对象的特点和访问模式，选择合适的数据结构来存储缓存对象，如HashMap、LinkedHashMap等，以减少内存占用并提高访问效率。

6. **使用对象池技术**：
   - 对于频繁创建和销毁的缓存对象，可以考虑使用对象池技术来减少GC的压力，提高内存利用率。

7. **及时释放不再使用的对象**：
   - 确保不再使用的缓存对象能够被垃圾回收器及时回收，例如，通过显式地将对象引用设置为null、关闭流等操作来释放资源。

8. **避免内存泄漏**：
   - 定期检查代码，确保没有内存泄漏的问题，如未关闭的资源、静态引用等，这些问题都可能导致内存占用过多，进而引发OOM错误。

9. **使用软引用和弱引用**：
   - 对于可回收的对象，可以考虑使用软引用（SoftReference）或弱引用（WeakReference），以便在JVM内存不足时能够被回收。

10. **持续监控和优化**：
    - 持续的监控、分析和优化是保持应用稳定运行的关键。根据应用的实际情况，不断调整和优化缓存策略、GC策略等，以减少内存占用并提高系统性能。

综上所述，通过合理配置JVM内存参数、选择合适的缓存实现、设置缓存大小和过期策略、监控缓存使用情况、优化数据结构、使用对象池技术、及时释放不再使用的对象、避免内存泄漏、使用软引用和弱引用以及持续监控和优化等措施，可以有效地防止Java多级缓存中的本地缓存引发OOM错误。

# 如何设计一个高并发项目 *

## 优化微服务

- 首先单体的架构升级为微服务架构,之后就可以分布式去部署服务提升并发能力

## Nginx限流+打散流量 *

- 对于web服务器也可以做优化,这里tomcat并发并不高,可以采用nginx,可以利用nginx的负载均衡然后在双11租多台流量机对流量打散
- 然后就是对恶意请求拦截,这里我是在Nginx层做了处理,Nginx对同一个ip每秒10个请求

## 微服务单一职责设计

- 并且微服务的设计也很重要,对于秒杀系统如果不跟别的系统抽离出来,不保证单一职责,如果秒杀系统挂了导致别的系统也挂了问题会很大,所以对于秒杀系统要做一个单独抽离

## 前端处理

- 按钮控制：
  - 一般的秒杀场景,按钮都是置灰的，只有时间到了，才能点击。

  - 这是因为怕大家在时间快到的最后几秒秒疯狂请求服务器，然后还没到秒杀的时候基本上服务器就挂了。

  - 这里我是让前端做了定时处理,直到时间才开放按钮

  - 但是这里会有另一个问题,就是万一有人提前把后端接口暴露了,别人可以绕过前端直接访问接口,所以后端这里做了秒杀URL加密处理

  - 然后做秒杀url加密处理

    - 这里考虑到会有人在前端页面f12拿到http请求到postman或者别的工具不停发请求抢购,所以这里url做了动态处理,这里跟前端规定好了,前端生成uuid,在其他服务器中创建一个随机的唯一数,然后存储到Redis中这里过期时间是1秒,我只允许你一秒的时间不停用这个path去发送,其中key是这个uuid,value是生成的随机数,然后把生成的这个随机path返回给前端,前端会继续发送一条真正的秒杀请求到秒杀服务器,秒杀服务器通过参数绑定获取请求中的path,秒杀服务器拿到uuid去redis查,比较请求中的path跟redis里的是否一致,一致就通过

    ![image-20241015215405167](https://pic-1329573580.cos.ap-nanjing.myqcloud.com/202410152154388.png)

## 服务之间通信优化 *

- 那么微服务架构也会设计服务与服务之间的通信,可以用rpc替代http

## **缓存**

- 然后就是对于高并发,是一定要考虑热点数据处理的,所以这里会采用**多级缓存的架构设计**保证万级qps
  - 用到了redis就一定存在,穿透,击穿,雪崩这类问题,对于这些问题也要去解决
  - 以及使用缓存就一定要考虑内存不够用的情况,所以对于内存淘汰策略需要好好考虑
  - 以及缓存的双写问题也需要去做考虑,一般来说保证最终一致性就ok
  - 对于单机Redis可以扩展集群,比如主从读写分离,哨兵保证主从故障转移保证高可用
  - 对于Redis防止挂掉可以对其做持久化处理,比如RDB和AOF
  - 对于内存爆掉可以开淘汰机制LRU或LFU

## 业务上的处理

- 对于业务上的处理,高并发项目一般都涉及秒杀功能
  - 既然有秒杀功能就可以使用乐观锁对一人一单问题做处理,不能一个人抢到多个秒杀商品
  - 以及秒杀也有库存,这里如果超卖了看具体需求,如果是允许超卖让商家补库存就不做什么过多处理,如果是不允许超卖就使用分布式锁防止超卖

## 限流

- 限流这里我觉得应该分为前端限流和后端限流。
  - **Nginx限流**:这里使用Nginx设置了对同一个ip每秒只能10个请求
  - **前端限流**：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。

## 库存预热

- 我们要开始秒杀前通过定时任务**提前把商品的库存加载到Redis中**，让整个流程都在Redis里面去做，然后等秒杀结束了，再异步的去修改库存就好了。所以这里异步也用上了MQ
- LUA脚本
  - 由于这里库存判断以及库存扣减都是在Redis里做,所以要用LUA保证多个Redis命令的原子性
- 削峰填谷：

  - 对于库存扣减操作,统一都在redis里做,然后使用MQ再异步的去修改库存就好了。
  - 既然用上了MQ,对于数据库的最终一致性是由MQ来完成,所以一定要保证他的高可用,比如镜像队列的主从
  - 以及防止消息丢失,开启ACK机制和持久化机制
  - 以及对幂等性做处理
